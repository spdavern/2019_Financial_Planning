---
title: "2019 Seed Financial Planning"
author: "Sean Davern"
date: "June 5, 2019"
output:
  html_notebook: default
  html_document:
    df_print: paged
  pdf_document: default
references:
- id: davern2013
  title: An Assessment of Requested Seed Core Support ofr Expansion Based on Analysis of Giving
  author:
  - family: Davern
    given: Sean
  container-title: Internal Report
  URL: "file://../Reports/'August 2013 Analysis of Giving.pdf'"
  DOI: 
  type: article-journal
  issued:
    year: 2013
    month: 8
    day: 21
---

# Import of Data
The original data was provided by John Earling in a work book entitled 'Weekly PayPay & Tithes .xls' workbook.  The layout/format of that workbook was not conducive to easily loading into R [nor JMP originally] and so was transcribed into the workbook 'Giving Data.xlsx' and then read into R.

```{r extract, message=FALSE}
source("../code/0-Extract data from Excel.R")
df  # This is the data frame resulting from the import.
```
# Some Minor Data Validation
As a first validation I'll check that the weekly PayPal and offering amounts sum to the weekly totals $(paypal_i+{offering}_i\overset{?}=total_i)$, reporting only those that aren't equal:
```{r validate totals}
source("../code/1-Validate totals.R")
```
Ok, so December 2015 and 2016 seem to have totals greater than accounted for by the PayPal and offering amounts.  That's perhaps explainable by other end-of-year giving coming in another way.  However, the April 2017 discrepancy seems to be missing $500.  I'll need to look into that.

# Data Transformation

Aggregating the monthly totals and preparing to model month values...
```{r}
# Data transformation: Calculate monthly giving totals.
# Make Month a categorical variable with levels in the order that
# months occur in the year otherwise months are sorted alphabetically.
df$month <- factor(df$month, month.name)
# Aggregate the monthly Totals from giving.data in sums for each month.
MonthTotals <- 
  aggregate(df$total, by = list(df$month, df$year), FUN = sum)
# Exclude the months that don't have totals yet.
MonthTotals <- MonthTotals[complete.cases(MonthTotals), ]
# Extract only rows containing 'monthly.giving.families' data.
df <- df[!is.na(df$monthly.giving.families),]
# Now replace Totals (which were weekly totals) with calculated aggregates
df$total <- MonthTotals$x
# paypal & offering columns are now misleading (only week's value) so remove them.
df <- select(df, -paypal, -offering) 
```
Adding the number of giving Sundays in the month and the average giving each week per month...
```{r}
source("../code/NumOfGivenDayOfWeekInMonth.R")
# Calculate and add the columns SundaysInMonth with calculated values
# and MonthsGivingPerWeek
df <-  df %>%
  mutate(SundaysInMonth =
           NumOfGivenDayOfWeekInMonth(df$week.ending, "Sunday")) %>%
  mutate(MonthsGivingPerWeek = total / SundaysInMonth)
```
Enable modeling year as factor...
```{r}
# Make year a categorical variable so coefficients are easier to interpret.
df$year <- as.factor(df$year)
```
Save the resulting tibble:
```{r echo=TRUE, eval=FALSE}  
# Code chunk eval=false so files don't get overwritten willy nilly.
# Write it as a csv:
write.csv(x = df,
          file = "../data/Cleaned and Transformed Giving Data.csv",
          row.names = FALSE)
# Save it as an R object that can be loaded into a new R object.
saveRDS(df, file = "../data/Cleaned and Transformed Giving Data.rds")
```

# Replicating Previous Modeling
The relatively simple model derived in 2013 [see @davern2013, pg. 11] and used again in 2018 used this model:
$$\text{Monthly Giving} = a_1+b_{year}+c_{month}$$
where $a_1$ is an overall grand average of the monthly giving amount, $b_{year}$ is an adjustment for the given year and $c_{month}$ is an adjustment for the month. The model was originally regressed on giving data from Jan 2010 through August 2013 excluding 3 high-fliers with known exceptional donations.
We can now regress this model:
```{r}
# Pair the data down to that used in the original analysis
df2 <- df[df$week.ending > "2010-01-01" & df$week.ending < "2013-07-31",] %>%
  mutate(excluded = FALSE)
df2$excluded[as.Date(df2$week.ending) == "2010-02-28"] <- TRUE
df2$excluded[as.Date(df2$week.ending) == "2012-04-29"] <- TRUE
df2$excluded[as.Date(df2$week.ending) == "2012-12-30"] <- TRUE
# Regress the model
mod <- lm(
  formula = total ~
    year + month,
  data = df2[df2$excluded!=TRUE,]
)
```

Showing the resulting predictions

```{r}
library("ggplot2")
library(RColorBrewer)
cbPalette <- brewer.pal(12,"Paired")  # Using http://colorbrewer2.org/
names(cbPalette) <- levels(df2$month)
colScale <- scale_color_manual(name = "month", values = cbPalette)
df3 <- mutate(df2, predicted.values = predict(mod,df2)) %>%
  mutate(residual.values = total - predicted.values )
library("gridExtra")
plot1 <- ggplot(df3, aes(x = week.ending, y = total, color=month )) + geom_point() +
  geom_line(color='blue', data = df3, aes(x=week.ending, y=predicted.values)) +
  colScale + labs(title = "Model Result")
plot2 <- ggplot(df3, aes(x = predicted.values, y = total, color=month)) + 
  geom_point() + geom_abline(intercept = 0, slope = 1, color="red") +
  colScale + labs(x = "Monthly Giving Predicted", y = "Monthly Giving Actual",
                  title = "Actual by Predicted Plot")
plot3 <- ggplot(df3, aes(x = predicted.values, y = residual.values, color = month)) +
  geom_point() + geom_hline(yintercept = 0, linetype="dashed", color = "blue") +
  colScale + labs(x = "Monthly Giving Predicted", y = "Monthly Giving Residual",
                  title = "Residual by Predicted Plot")
plot4 <- ggplot(df3, aes(x = as.numeric(row.names(df3)), y = residual.values, 
                color = month)) + 
  geom_point() + geom_hline(yintercept = 0) + colScale +
  labs(x = "Row Number", y = "Residual")
grid.arrange(plot1,plot2, plot3, plot4, ncol=2, nrow=2)
```



# References